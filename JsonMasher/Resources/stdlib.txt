# Ripped out from https://github.com/stedolan/jq/blob/master/src/builtin.jq :-)

def keys_unsorted: keys;

# TODO: def halt_error: halt_error(5);
# TODO: def error(msg): msg|error;
def map(f): [.[] | f];
def select(f): if f then . else empty end;
def sort_by(f): _sort_by_impl(map([f]));
# TODO: def group_by(f): _group_by_impl(map([f]));
# TODO: def unique: group_by(.) | map(.[0]);
# TODO: def unique_by(f): group_by(f) | map(.[0]);
# TODO: def max_by(f): _max_by_impl(map([f]));
# TODO: def min_by(f): _min_by_impl(map([f]));
def add: reduce .[] as $x (null; . + $x);
def del(f): delpaths([path(f)]);
# C# builtin: def _assign(paths; $value): reduce path(paths) as $p (.; setpath($p; $value));
# C# builtin: def _modify(paths; update): reduce path(paths) as $p (.; label $out | (setpath($p; getpath($p) | update) | ., break $out), delpaths([$p]));
def map_values(f): .[] |= f;

# recurse
def recurse(f): def r: ., (f | r); r;
def recurse(f; cond): def r: ., (f | select(cond) | r); r;
def recurse: recurse(.[]?);
def recurse_down: recurse;

def to_entries: [keys_unsorted[] as $k | {key: $k, value: .[$k]}];
def from_entries: map({(.key // .Key // .name // .Name): (if has("value") then .value else .Value end)}) | add | . // {};
def with_entries(f): to_entries | map(f) | from_entries;
def reverse: [.[length - 1 - range(0;length)]];
# TODO: def indices($i): if type == "array" and ($i|type) == "array" then .[$i]
# TODO:   elif type == "array" then .[[$i]]
# TODO:   elif type == "string" and ($i|type) == "string" then _strindices($i)
# TODO:   else .[$i] end;
# TODO: def index($i):   indices($i) | .[0];       # TODO: optimize
# TODO: def rindex($i):  indices($i) | .[-1:][0];  # TODO: optimize
def paths: path(recurse(if (type|. == "array" or . == "object") then .[] else empty end))|select(length > 0);
def paths(node_filter): . as $dot|paths|select(. as $p|$dot|getpath($p)|node_filter);
def isfinite: type == "number" and (isinfinite | not);
def arrays: select(type == "array");
def objects: select(type == "object");
def iterables: select(type|. == "array" or . == "object");
def booleans: select(type == "boolean");
def numbers: select(type == "number");
def normals: select(isnormal);
def finites: select(isfinite);
def strings: select(type == "string");
def nulls: select(. == null);
def values: select(. != null);
def scalars: select(type|. != "array" and . != "object");
def leaf_paths: paths(scalars);
# TODO: def join($x): reduce .[] as $i (null;
# TODO:             (if .==null then "" else .+$x end) +
# TODO:             ($i | if type=="boolean" or type=="number" then tostring else .//"" end)
# TODO:         ) // "";
# TODO: def _flatten($x): reduce .[] as $i ([]; if $i | type == "array" and $x != 0 then . + ($i | _flatten($x-1)) else . + [$i] end);
# TODO: def flatten($x): if $x < 0 then error("flatten depth must not be negative") else _flatten($x) end;
# TODO: def flatten: _flatten(-1);
# C# builtin: def range($x): range(0;$x);
# TODO: def fromdateiso8601: strptime("%Y-%m-%dT%H:%M:%SZ")|mktime;
# TODO: def todateiso8601: strftime("%Y-%m-%dT%H:%M:%SZ");
# TODO: def fromdate: fromdateiso8601;
# TODO: def todate: todateiso8601;
# TODO: def match(re; mode): _match_impl(re; mode; false)|.[];
# TODO: def match($val): ($val|type) as $vt | if $vt == "string" then match($val; null)
# TODO:    elif $vt == "array" and ($val | length) > 1 then match($val[0]; $val[1])
# TODO:    elif $vt == "array" and ($val | length) > 0 then match($val[0]; null)
# TODO:    else error( $vt + " not a string or array") end;
# TODO: def test(re; mode): _match_impl(re; mode; true);
# TODO: def test($val): ($val|type) as $vt | if $vt == "string" then test($val; null)
# TODO:    elif $vt == "array" and ($val | length) > 1 then test($val[0]; $val[1])
# TODO:    elif $vt == "array" and ($val | length) > 0 then test($val[0]; null)
# TODO:    else error( $vt + " not a string or array") end;
# TODO: def capture(re; mods): match(re; mods) | reduce ( .captures | .[] | select(.name != null) | { (.name) : .string } ) as $pair ({}; . + $pair);
# TODO: def capture($val): ($val|type) as $vt | if $vt == "string" then capture($val; null)
# TODO:    elif $vt == "array" and ($val | length) > 1 then capture($val[0]; $val[1])
# TODO:    elif $vt == "array" and ($val | length) > 0 then capture($val[0]; null)
# TODO:    else error( $vt + " not a string or array") end;
# TODO: def scan(re):
# TODO:   match(re; "g")
# TODO:   |  if (.captures|length > 0)
# TODO:       then [ .captures | .[] | .string ]
# TODO:       else .string
# TODO:       end ;
# TODO: #
# TODO: # If input is an array, then emit a stream of successive subarrays of length n (or less),
# TODO: # and similarly for strings.
# TODO: def _nwise(a; $n): if a|length <= $n then a else a[0:$n] , _nwise(a[$n:]; $n) end;
# TODO: def _nwise($n): _nwise(.; $n);
# TODO: #
# TODO: # splits/1 produces a stream; split/1 is retained for backward compatibility.
# TODO: def splits($re; flags): . as $s
# TODO: #  # multiple occurrences of "g" are acceptable
# TODO:   | [ match($re; "g" + flags) | (.offset, .offset + .length) ]
# TODO:   | [0] + . +[$s|length]
# TODO:   | _nwise(2)
# TODO:   | $s[.[0]:.[1] ] ;
# TODO: def splits($re): splits($re; null);
# TODO: #
# TODO: # split emits an array for backward compatibility
# TODO: def split($re; flags): [ splits($re; flags) ];
# TODO: #
# TODO: # If s contains capture variables, then create a capture object and pipe it to s
# TODO: def sub($re; s):
# TODO:   . as $in
# TODO:   | [match($re)]
# TODO:   | if length == 0 then $in
# TODO:     else .[0]
# TODO:     | . as $r
# TODO: #  # create the "capture" object:
# TODO:     | reduce ( $r | .captures | .[] | select(.name != null) | { (.name) : .string } ) as $pair
# TODO:         ({}; . + $pair)
# TODO:     | $in[0:$r.offset] + s + $in[$r.offset+$r.length:]
# TODO:     end ;
# TODO: #
# TODO: # If s contains capture variables, then create a capture object and pipe it to s
# TODO: def sub($re; s; flags):
# TODO:   def subg: [explode[] | select(. != 103)] | implode;
# TODO:   # "fla" should be flags with all occurrences of g removed; gs should be non-nil if flags has a g
# TODO:   def sub1(fla; gs):
# TODO:     def mysub:
# TODO:       . as $in
# TODO:       | [match($re; fla)]
# TODO:       | if length == 0 then $in
# TODO:         else .[0] as $edit
# TODO:         | ($edit | .offset + .length) as $len
# TODO:         # create the "capture" object:
# TODO:         | reduce ( $edit | .captures | .[] | select(.name != null) | { (.name) : .string } ) as $pair
# TODO:             ({}; . + $pair)
# TODO:         | $in[0:$edit.offset]
# TODO:           + s
# TODO:           + ($in[$len:] | if length > 0 and gs then mysub else . end)
# TODO:         end ;
# TODO:     mysub ;
# TODO:     (flags | index("g")) as $gs
# TODO:     | (flags | if $gs then subg else . end) as $fla
# TODO:     | sub1($fla; $gs);
# TODO: #
# TODO: def sub($re; s): sub($re; s; "");
# TODO: # repeated substitution of re (which may contain named captures)
# TODO: def gsub($re; s; flags): sub($re; s; flags + "g");
# TODO: def gsub($re; s): sub($re; s; "g");
# TODO: 
# TODO: ########################################################################
# TODO: # generic iterator/generator
# TODO: def while(cond; update):
# TODO:      def _while:
# TODO:          if cond then ., (update | _while) else empty end;
# TODO:      _while;
# TODO: def until(cond; next):
# TODO:      def _until:
# TODO:          if cond then . else (next|_until) end;
# TODO:      _until;
# C# builtin: def limit($n; exp):
# C# builtin:     if $n > 0 then label $out | foreach exp as $item ($n; .-1; $item, if . <= 0 then break $out else empty end)
# C# builtin:     elif $n == 0 then empty
# C# builtin:     else exp end;
# C# builtin: # range/3, with a `by` expression argument
# C# builtin: def range($init; $upto; $by):
# C# builtin:     if $by > 0 then $init|while(. < $upto; . + $by)
# C# builtin:   elif $by < 0 then $init|while(. > $upto; . + $by)
# C# builtin:   else empty end;
# TODO: def first(g): label $out | g | ., break $out;
# TODO: def isempty(g): first((g|false), true);
# TODO: def all(generator; condition): isempty(generator|condition and empty);
# TODO: def any(generator; condition): isempty(generator|condition or empty)|not;
# TODO: def all(condition): all(.[]; condition);
# TODO: def any(condition): any(.[]; condition);
# TODO: def all: all(.[]; .);
# TODO: def any: any(.[]; .);
# TODO: def last(g): reduce g as $item (null; $item);
# TODO: def nth($n; g): if $n < 0 then error("nth doesn't support negative indices") else last(limit($n + 1; g)) end;
# TODO: def first: .[0];
# TODO: def last: .[-1];
# TODO: def nth($n): .[$n];
# TODO: def combinations:
# TODO:     if length == 0 then [] else
# TODO:         .[0][] as $x
# TODO:           | (.[1:] | combinations) as $y
# TODO:           | [$x] + $y
# TODO:     end;
# TODO: def combinations(n):
# TODO:     . as $dot
# TODO:       | [range(n) | $dot]
# TODO:       | combinations;
# TODO: # transpose a possibly jagged matrix, quickly;
# TODO: # rows are padded with nulls so the result is always rectangular.
# TODO: def transpose:
# TODO:   if . == [] then []
# TODO:   else . as $in
# TODO:   | (map(length) | max) as $max
# TODO:   | length as $length
# TODO:   | reduce range(0; $max) as $j
# TODO:       ([]; . + [reduce range(0;$length) as $i ([]; . + [ $in[$i][$j] ] )] )
# TODO: 	        end;
# TODO: def in(xs): . as $x | xs | has($x);
# TODO: def inside(xs): . as $x | xs | contains($x);
# TODO: def repeat(exp):
# TODO:      def _repeat:
# TODO:          exp, _repeat;
# TODO:      _repeat;
# TODO: def inputs: try repeat(input) catch if .=="break" then empty else error end;
# TODO: # like ruby's downcase - only characters A to Z are affected
# TODO: def ascii_downcase:
# TODO:   explode | map( if 65 <= . and . <= 90 then . + 32  else . end) | implode;
# TODO: # like ruby's upcase - only characters a to z are affected
# TODO: def ascii_upcase:
# TODO:   explode | map( if 97 <= . and . <= 122 then . - 32  else . end) | implode;
# TODO: 
# TODO: # Streaming utilities
# TODO: def truncate_stream(stream):
# TODO:   . as $n | null | stream | . as $input | if (.[0]|length) > $n then setpath([0];$input[0][$n:]) else empty end;
# TODO: def fromstream(i): {x: null, e: false} as $init |
# TODO:   # .x = object being built; .e = emit and reset state
# TODO:   foreach i as $i ($init
# TODO:   ; if .e then $init else . end
# TODO:   | if $i|length == 2
# TODO:     then setpath(["e"]; $i[0]|length==0) | setpath(["x"]+$i[0]; $i[1])
# TODO:     else setpath(["e"]; $i[0]|length==1) end
# TODO:   ; if .e then .x else empty end);
# TODO: def tostream:
# TODO:   path(def r: (.[]?|r), .; r) as $p |
# TODO:   getpath($p) |
# TODO:   reduce path(.[]?) as $q ([$p, .]; [$p+$q]);
# TODO: 
# TODO: 
# TODO: # Assuming the input array is sorted, bsearch/1 returns
# TODO: # the index of the target if the target is in the input array; and otherwise
# TODO: #  (-1 - ix), where ix is the insertion point that would leave the array sorted.
# TODO: # If the input is not sorted, bsearch will terminate but with irrelevant results.
# TODO: def bsearch($target):
# TODO:   if length == 0 then -1
# TODO:   elif length == 1 then
# TODO:      if $target == .[0] then 0 elif $target < .[0] then -1 else -2 end
# TODO:   else . as $in
# TODO:     # state variable: [start, end, answer]
# TODO:     # where start and end are the upper and lower offsets to use.
# TODO:     | [0, length-1, null]
# TODO:     | until( .[0] > .[1] ;
# TODO:              if .[2] != null then (.[1] = -1)               # i.e. break
# TODO:              else
# TODO:                ( ( (.[1] + .[0]) / 2 ) | floor ) as $mid
# TODO:                | $in[$mid] as $monkey
# TODO:                | if $monkey == $target  then (.[2] = $mid)   # success
# TODO:                  elif .[0] == .[1]     then (.[1] = -1)     # failure
# TODO:                  elif $monkey < $target then (.[0] = ($mid + 1))
# TODO:                  else (.[1] = ($mid - 1))
# TODO:                  end
# TODO:              end )
# TODO:     | if .[2] == null then          # compute the insertion point
# TODO:          if $in[ .[0] ] < $target then (-2 -.[0])
# TODO:          else (-1 -.[0])
# TODO:          end
# TODO:       else .[2]
# TODO:       end
# TODO:   end;
# TODO: 
# TODO: # Apply f to composite entities recursively, and to atoms
# TODO: def walk(f):
# TODO:   . as $in
# TODO:   | if type == "object" then
# TODO:       reduce keys_unsorted[] as $key
# TODO:         ( {}; . + { ($key):  ($in[$key] | walk(f)) } ) | f
# TODO:   elif type == "array" then map( walk(f) ) | f
# TODO:   else f
# TODO:   end;
# TODO: 
# TODO: # SQL-ish operators here:
# TODO: def INDEX(stream; idx_expr):
# TODO:   reduce stream as $row ({}; .[$row|idx_expr|tostring] = $row);
# TODO: def INDEX(idx_expr): INDEX(.[]; idx_expr);
# TODO: def JOIN($idx; idx_expr):
# TODO:   [.[] | [., $idx[idx_expr]]];
# TODO: def JOIN($idx; stream; idx_expr):
# TODO:   stream | [., $idx[idx_expr]];
# TODO: def JOIN($idx; stream; idx_expr; join_expr):
# TODO:   stream | [., $idx[idx_expr]] | join_expr;
# TODO: def IN(s): any(s == .; .);
# TODO: def IN(src; s): any(src == s; .); 